# vagrant setup on wsl ubuntu
# change with the version you have on win
 wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
 echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
 sudo apt update && sudo apt install vagrant=2.4.0-1
# vagrant version must match beween win and wsl
# in .bashrc add the following
export VAGRANT_WSL_ENABLE_WINDOWS_ACCESS="1"
source .bashrc
# install plugin
vagrant plugin install virtualbox_WSL2

# sample vagrant file
# remember to run vagrant destroy before updating vagrant file
# or used vagrant reload
VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

    config.vm.define :server1 do |server1|
      server1.vm.hostname = "server1"
      server1.vm.box = "generic/centos9s"
      server1.vm.network "private_network", ip: "192.168.56.1"
    end
    
    config.vm.define :server2 do |server2|
      server2.vm.hostname = "server2"
      server2.vm.box = "generic/centos9s"
      server2.vm.network "private_network", ip: "192.168.56.2"
    end
    
    config.vm.provision "ansible" do |ansible|
      ansible.compatibility_mode = "2.0"
      ansible.verbose = "v"
      ansible.playbook = "playbook.yml"
      # ansible.inventory_path = "inventory"
      ansible.become = true
    end
    
  end

# https://blog.thenets.org/how-to-run-vagrant-on-wsl-2/
# https://docs.ansible.com/ansible/latest/scenario_guides/guide_vagrant.html

# docs
# https://docs.ansible.com/ansible/latest/getting_started/index.html

# installing prereq on ubuntu
sudo apt update
sudo apt install software-properties-common
sudo apt-add-repository --yes --update ppa:ansible/ansible
# for centos9 add repa ass follows
# dnf config-manager --add-repo https://github.com/ansible-community/ppa
sudo apt install ansible sshpass
ansible --version

# ansible config
# The effective Ansible configuration is applied on the first found – first applied basis. 
# It is important to note that only one configuration can be active and applied 
# and that these configurations are NOT cumulative.
# The search order is shown in the following bulleted list, 
# with the search from the top of the list to the bottom. 
# The least effective configuration is the /etc/ansible/ansible.cfg at the bottom of the list.
# ANSIBLE_CONFIG: 
#    If the environment variable, ANSIBLE_CONFIG, is set, then this configuration is used. 
#    Default options are used for any configuration option not set. 
#    This default behavior is common with all configurations.
# ansible.cfg: 
#    If there is an ansible.cfg file in the current working directory (CWD), 
#    AND the ANSIBLE_CONFIG environment variable has not been set, 
#    then it is this file that is used.
# ~/.ansible.cfg: 
#    If no previously listed configuration is detected, 
#    Ansible will check the current user’s home directory for a hidden file called .ansible.cfg. 
#    If the file exists, then it becomes the third choice within the hierarchy. 
#    This is a great option for a user to create, acting as a default for all user projects 
#    except those needing a little tweaking. 
#    Those needing tweaks can have a configuration file added to the project directory;
#    alternatively, as you will learn, variables can be set to
#    overwrite certain options as can settings within Ansible Playbooks. 
#    So, there are lots of options to tweak the configuration as needed.
# /etc/ansible/ansible.cfg: 
#    The default file where no other configuration is in place or detected. 
#    The file itself only contains comments, 
#    meaning that there are no effective settings from the file. 
#    This will result in the default settings being applied for all settings. 
#    The file itself is not wasted, acting as great documentation 
#    for the configuration files that you may want to implement.

# config example
# you can use default cfg file for now
# no need to change anything here
$ code $HOME/.ansible.cfg
[defaults]
remote_user = vagrant
# host_key_checking = false
inventory = inventory
[privilege_escalation]
become = True
become_method = sudo
become_user = root
become_ask_pass = False

# first playbook
$ vim software.yml
---
- name: My first play
  hosts: all
  become: true
  tasks:
  - name: Install software
    package:
      name: bash-completion
      state: present
...

# sample generic inventory
cat /etc/ansible/hosts

# take the inventory generated by vagrant
mv ~/.vagrant/provisioners/ansible/inventory/vagrant_ansible_inventory ~/inventory
# uncomment line 
# ansible.inventory_path = "inventory" 
# in vagrant file
# inventory file contents example
# server2 ansible_host=172.26.144.1 ansible_port=2200 ansible_user='vagrant' ansible_ssh_private_key_file='/home/cip/.vagrant/machines/server2/virtualbox/private_key'
# server1 ansible_host=172.26.144.1 ansible_port=2222 ansible_user='vagrant' ansible_ssh_private_key_file='/home/cip/.vagrant/machines/server1/virtualbox/private_key'

# example with pass instead of key 
# NOT SECURE
# [all:vars]
# ansible_connection=ssh
# ansible_user=vagrant
# ansible_ssh_pass=vagrant

# take the default vagrant inventory 
# move it in your working directoy
cp .vagrant/provisioners/ansible/inventory/vagrant_ansible_inventory ./inventory

# add inventory hostgroups
[web]
server2 ansible_host=172.26.144.1 ansible_port=2200 ansible_user='vagrant' ansible_ssh_private_key_file='/home/cip/.vagrant/machines/server2/virtualbox/private_key'
[db]
server1 ansible_host=172.26.144.1 ansible_port=2222 ansible_user='vagrant' ansible_ssh_private_key_file='/home/cip/.vagrant/machines/server1/virtualbox/private_key'
[servers:children]
db
web

# add this line in the ansible section of your vagrant file
ansible.inventory_path = "inventory"

# test config using 
vagrant reload
vagrant provision

# tips
# Keep it simple: At its launch, Ansible was
# positioned as a solution that is simpler than the
# others. That goes for the playbooks and other
# solutions you’ll develop as well. Keep it simple, and
# it will be easier for others to understand what you
# had in mind.
# • Make it readable: As with anything in IT, you can
# make it very complex and use compact structures to
# ensure that nobody understands what you were
# trying to do. That approach doesn’t make sense. You
# should keep it readable, and that starts with your
# development of Ansible playbooks.
# • Use a declarative approach: In Ansible, it’s all
# about the desired state. The purpose of Ansible is to
# bring managed assets in the desired state,
# regardless of the current state, and make only the
# modifications that are necessary. The desired state
# is implemented in playbooks, and using playbooks
# to make the current state match the desired state is
# what is known as the declarative approach.
# • Use specific solutions: On many occasions, you’ll
# find that multiple solutions are available to reach a
# specific desired state. For instance, you can use the
# command module to run arbitrary commands,
# making it possible to accomplish almost anything.
# You shouldn’t, though. To make sure that you get
# the desired result, use the most specific solution. So
# if, for instance, a user module allows you to create
# users, use that module and don’t use the Linux
# useradd command with the command module.


# inventory commands
ansible -i inventory all --list-hosts
# list all servers in human readable format
ansible -i inventory ungrouped --list-hosts
# list only ungrouped servers
ansible-inventory -i inventory --list
# list in json format
ansible-inventory -i inventory --graph
# list hierarchy

# we can used dinamic inventories in larger environments
# https://docs.ansible.com/ansible/latest/inventory_guide/intro_dynamic_inventory.html

# ad hoc commands
ansible all -i inventory -b -m user -a "name=lisa"

# core modules.

# command
# The command module allows users to run arbitrary
# commands using Ansible. Commands that are run by the
# command module are not interpreted by a shell. This
# means that common shell features, such as pipes and
# redirects, don’t work while using the command module.
# For instance, the command 
ansible all -m command -a "rpm -qa | grep nmap" 
# does not work.
# The command module is the default module. This means
# that if the option -m command is omitted, Ansible
# interprets the argument that is provided by default as an
# argument to the command module. If another default
# module is needed, the option module_name = module
# can be set in ansible.cfg.

# shell
# The shell module is similar to the command module and
# allows you to run arbitrary commands, with one
# important difference: the shell module does run the
# commands through a shell. That means the usual shell
# features, such as pipes and redirects, do work while using
# this module. Compare, for instance, the result of the
# command ansible all -m shell -a “rpm -qa | grep
# nmap” to the command used before. This time it will work.

# raw
# The third module that enables you to run arbitrary
# commands on managed nodes is the raw module. The
# shell and the command modules, when used, generate a
# Python script, which is sent over SSH to be executed on
# the managed host. The raw module, however, doesn’t
# need Python on the managed host; it sends the command
# straight over the SSH connection. This makes the raw
# module an excellent choice while setting up a machine or
# to work on a managed machine that doesn’t have a
# Python stack, such as a network device.
# Using the appropriate options, you can use the raw
# module to perform initial setup tasks on managed hosts.
# An example is the command ansible -u root -i
# inventory ansible3 --ask-pass -m raw -a “yum
# install python3”, which can be used to install Python 3
# on host ansible3, which may be a node that hasn’t
# received any Ansible configuration yet. Notice that the
# raw module could be used as an alternative to the
# command or shell module, but this approach is not
# recommended. As a generic rule of thumb, you should
# always try to use the module that is the most specific for
# the task that you want to accomplish.

# copy
# As its name suggests, the copy module is used to copy
# things. You can use it to copy files, but you can also use it
# to copy simple lines of text into a managed files. An
# example is ansible all -m copy -a 'content="hello
# world" dest=/etc/motd', which copies the text “hello
# world” into the /etc/motd file.

# yum
# The yum module can be installed to manage software on
# the Red Hat distribution and related distributions. Use,
# for example, ansible all -m yum -a “name=nmap
# state=latest” to install the latest version of the nmap
# package on all managed nodes. Notice that yum is not
# the only module available for managing software. A more
# generic module is package, which has the advantage that
# it works on any Linux distribution. Between the two of
# them, use the yum module if you need to work with
# specific yum command features, and use the package
# module if the highest priority is to manage software on
# different managed distributions.

# service
# The service module is used to manage the state of
# services through either the legacy system V (init)
# process, or systemd. While using it, make sure that you
# don’t just start the service using the argument
# state=started, but also enable the service using
# enabled=yes. If you just use state=started, the managed
# service is started now but won’t be started automatically
# again after a restart. It’s like using systemctl start
# myservice without using systemctl enable myservice.
# Use, for instance, ansible all -m service -a
# “name=httpd state=started enabled=yes” to
# enable and start the httpd service. (Obviously, you have
# to use the yum module to install the httpd service before
# you can do that.)

# ping
# The ping module is a simple module that can be used to
# check whether hosts have been set up correctly to be
# managed with Ansible. So it doesn’t just test
# connectivity; it tests manageability. It doesn’t need any
# arguments. Just use ansible all -m ping to check
# connectivity for all hosts in inventory. Listing 4-2 shows
# what the answer looks like for hosts that are available but
# also shows what you see if a host is not available. To get
# the same result, just add the hostname ansible3 to the
# inventory file. In Exercise 4-2 you can practice working
# with this module as well as the other modules discussed
# here.

# 1. Use 
ansible all -m ping 
# to verify that all hosts in inventory are in a manageable state.
# 2. Type 
ansible web -m yum -a "name=httpd state=installed" 
# to install the httpd software package on host server1.
# 3. Verify that the package is installed using
ansible all -m command -a "rpm -qa | grep httpd"
#Analyzing the output, you can see that the rpm -qa command 
# runs successfully on the managed hosts, but the pipe is ignored.
# 4. Use 
ansible all -m shell -a "rpm -qa | grep httpd"
# In the output you can see that node server1
# gives a “non-zero return code” message,
# meaning that the command did not complete successfully. 
# You can also see a list of matching
# packages on server2. Last, you can see a
# warning message stating that you should use the
# yum module instead. Notice that the shell as
# well as the command modules reported a
# changed status as the result, even if nothing has
# really changed.
# 5. Use 
ansible all -m yum -a "list=httpd" 
# and compare the output to the output of the 
# command used in step 4.
# 6. Use 
ansible all -m command -a "systemctl status httpd" 
# to verify the current status of the
# httpd service. It should show the service is not
# found on server1 and the service is inactive and
# disabled on server2.
# 7. Use 
ansible server1 -m service -a "name=httpd enabled=yes state=started"
# to start and enable the httpd service on server1.
# 8. Run the command 
ansible all -m command -a "systemctl status httpd" 
# again to verify the modification has been applied.

# see local documentation
ansible-doc -l
ansible-doc -l | grep vmware
ansible-doc ping

# online doc 
# https://docs.ansible.com

# using playbooks
---
- name: install start and enable httpd
  hosts: web
  tasks:
  - name: install package
    yum:
      name: httpd
      state: installed
  - name: start and enable service
    service:
      name: httpd
      state: started
      enabled: yes

# At the start of each playbook, you find three dashes.
# Optionally, you may also find three dots at the end of the
# playbook. Using these characters makes it easy to embed
# the playbook code into something else and easily isolate
# the playbook code when it is included.

# While you’re working with playbooks, the target hosts
# are specified in the play, not in the command that runs
# the playbook (which happens in ad hoc commands).
# After you indicate the target hosts, you specify a list of
# tasks. Each item in the list is identified with a hyphen.
# For each task, you specify the Ansible module that the
# task is running and a name. Notice that using names for
# tasks is not mandatory but is highly recommended,
# because using names makes it a little easier to identify
# which tasks have been able to run successfully. Next, you
# should identify the arguments that the task should be running.
# To identify hierarchical relations in playbooks, you use
# indentation. The basic rules for indentation are easy:
# Data elements at the same level in the hierarchy
# must have the same indentation.
# Items that are children (properties) and another
# element are indented more than the parents.

# You create indentation using spaces. There is no
# requirement for how many spaces to use, but using two
# spaces is common. Using tabs for indentation is not
# permitted.
# Using TABS for indentation is NOT PERMITTED.

# Within the playbook, one or more plays are defined.
# Plays are the highest level in the playbook, and each play
# starts with a hyphen. The reason is that the playbook
# defines a list of plays, and it is valid if the list contains
# just one play. All properties of the play (name, hosts, and
# the word tasks) are indented at the same level, and next
# there is a list of tasks. The list of tasks is a property of the
# play, and these tasks are indented one level deeper than
# the parent items to show the hierarchical relation
# between play and tasks. The next level of indentation
# happens at the task argument level, where each
# argument that is passed to a task is indented one more
# level deeper.

# config vim for using two space instead of tab character
# add to ~/.vimrc
# autocmd FileType yaml setlocal ai ts=2 sw=2 et

# execute playbook
ansible-playbook playbook.yml

# YAML
# YAML is all about defining key-value pairs, also known
# as dictionaries. An example of such a key-value pair is
# name: vsftpd. Key-value pairs can be defined in two
# ways: key: value or key=value. Of these two, the first
# method is preferred, but the second way works also.
# If an object in YAML needs multiple key-value pairs to
# define its properties, it is common to define one keyvalue
# pair on a line, for example :
# - name: enable vsftpd
#   service: name=vsftpd enabled=true
# is the same as
# - name: enable vsftpd
#   service: 
#     name: vsftpd
#     enabled: true
# the seccond option is the one reccomended to use

# lists
# While you’re working with YAML in Ansible playbooks,
# keys can have one value, and some keys can have
# multiple values. No standard rule defines what is the
# case in which situation. Whether a key can contain
# multiple values depends on the Ansible module. When
# you use the yum module, for instance, you can specify a
# list of packages to the name key. When you use the
# service module, for instance, it’s not possible to specify a
# list as the argument to the name key.

---
- name: using lists
  hosts: all
  tasks:
  - name: install packages
    yum:
      name:
      - nmap
      - httpd
      - vsftpd
      state: latest

# strings
# In YAML files, you include strings on multiple occasions.
# Using strings is not difficult because the string doesn’t
# have to be escaped by using quotation marks. However,
# you are allowed to use quotation marks anyway. This
# means that all the following notations are valid:
# Line of text
# "Line of text"
# 'Line of text'
# There are two ways to deal with multiline strings. You
# can use the | sign in a multiline string to take over all
# newline characters. If all text in a multiline string just
# needs to be treated as a line of text, without any further
# formatting, you can use the > sign. Use the | sign if you
# want to maintain formatting. Use the > sign if you want
# to split text over multiple lines in the playbook for better
# readability, but the lines don’t have to be written as
# multiple lines in the target file.

# syntax-check
ansible-playbook --syntax-check playbook.yml
# yaml with errors
---
- name: install start and enable httpd
  hosts: all
  tasks:
  - name: install package
    yum:
    name: httpd
      state: latest
  - service:
    name: httpd
      state: started
      enabled: yes

# dry run
ansible-playbook -C playbook.yml

# yaml exercises
# 1. Open an editor to create the file exercise.yaml.
#     Define the playbook header by including the
#     following lines:
---
- name: copy multiline text
  hosts: ansible1
  tasks:
# 2. Add the first task. In this task you use the copy
#     module, using content and the | sign to copy
#     two lines of text to a file that does not yet exist:
---
- name: copy multiline text
  hosts: ansible1
  tasks:
  - name: copy text
    copy:
      content: |
        line 1 test
        line 2 new test
      dest: /tmp/multiline1.txt
# 3. Add a second task that also uses the copy
#     module but this time uses the > sign:
---
- name: copy multiline text
  hosts: ansible1
  tasks:
  - name: copy text
  copy:
    content: |
      line 1
      line 2
    dest: /tmp/multiline1.txt
  - name: copy more text
  copy:
    content: >
      line 1
      line 2
    dest: /tmp/multiline2.txt
# 4. Use 
ansible-playbook exercise.yaml
#     to run the playbook and verify that in the output
#     you see two tasks reporting a changed status.
# 5. Verify the files that have been created. First, use
ansible ansible1 -a "cat /tmp/multiline1.txt" 
#     to verify the contents of the first file. 
#     Notice that it contains multiple lines.
# 6. Next, use 
ansible ansible1 -a "cat /tmp/multiline2.txt" 
# to verify that the file contains 
# all the separate lines on one single line.

# multiple playbooks

# Many playbooks that you find out in the wild
# work with multiple plays though. Using multiple plays in
# a playbook makes it easy to perform the complete setup
# of a managed environment, where you can set up one
# group of servers with one specific configuration and
# another group of servers with another configuration.
# When you work with multiplay playbooks, each play has
# its own list of hosts to address.

# When you are writing playbooks, there are many options.
# It might seem tempting to write huge playbooks,
# including many tasks and multiple plays. Doing so is not
# recommended as a best practice though. To summarize
# the most important guideline from the best practices:
# keep it simple. If there is no need to put everything in
# one playbook, then simply don’t. The bigger the
# playbook, the more difficult it will be to troubleshoot

# example multiple playbooks in the same file
---
- name: install start and enable httpd
  hosts: all
  tasks:
  - name: install package
    yum:
      name: httpd
      state: latest
  - name: start and enable service
    service:
      name: httpd
      state: started
      enabled: yes
- name: test httpd accessibility
  hosts: localhost
  tasks:
  - name: test httpd access
    uri:
      url: http://ansible1

# examples of import playbook
# https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse.html

# we can controll levels of verbosity with the following options
# -v
# -vv
# -vvv
# -vvvv
# when using ansible-playbook to run playbooks

# variables and facts
# syntax example
---
- name: create a user using a variable
  hosts: server1
  vars:
    users: lisa
  tasks:
    - name: create a user {{ users }} on host {{ansible_facts['hostname']}}
      user:
      name: "{{ users }}"

# In thie vars section, one variable is defined,
# using the common key: value syntax. Next, in the task
# definition the user module is used to work with this
# variable. To refer to the variable, you just place the name
# definition between double curly brackets. However, in
# the name argument to the user module, the variable is
# between double quotes and double curly braces. The
# reason is that the value in this case starts with the
# variable. If a value starts with a variable, the variable
# must be placed between double quotes. If more than just
# the variable name in the line specifies the value, the
# entire line that starts with the variable must be between
# double quotes.

# Next you see the variable ansible_hostname, which is not
# defined anywhere. That is because this variable is an
# Ansible fact. Ansible facts are also used as variables, but
# they are variables that are automatically set, based on
# properties of the managed system. Fact discovery is used
# by default to discover all that Ansible possibly might
# want to know about a machine to use in conditionals.

# Ansible facts are system properties that are collected
# when Ansible executes on a remote system. After facts
# are gathered, the facts can be used as variables. Apart
# from the system facts, which just exist as a system
# property, there are custom facts. 

# see all facts 
---
- name: show fact gathering
  hosts: all
  tasks:
  - name: show all facts
    debug:
      var: ansible_facts

# ways to adress facts
# square brackets
ansible_facts['default_ipv4']['address']
# dots
ansible_facts.default_ipv4.address
# square brackets are prefered

# Note that Ansible gathers a lot of facts by default. Some
# information is not included, though, and if that type of
# information is needed, it may be collected using
# additional modules. For an overview of all available
# modules for gathering specific types of facts, type
# ansible-doc -l | grep fact. This command shows that a
# wide range of fact gathering modules is available. One of
# these modules is package_facts, which collects
# information about software packages installed on
# managed hosts.

# In Ansible versions since 2.5, all facts are stored in
# one variable: ansible_facts. This method is used
# while gathering facts from a playbook
# Before Ansible version 2.5, facts were injected into
# variables such as ansible_hostname. This method is
# used by the setup module. (Note that this may
# change in future versions of Ansible.)

# Custom Facts
# Apart from the facts that can be gathered in all cases,
# Ansible also offers an option to work with custom facts. A
# custom fact is used to provide a host with arbitrary
# values that Ansible can use to change the behavior of
# plays. Custom facts can be provided as static files. These
# files must be in either INI or JSON format, have the
# extension .fact, and on the managed hosts must be stored
# in the /etc/ansible/facts.d directory.
# Alternatively, custom facts can be generated by a script,
# and in that case the only requirement is that the script
# must generate its output in JSON format. Dynamic
# custom facts are useful because they allow the facts to be
# determined at the moment that a script is running.
# An example of a static custom fact file.
# cat custom.fact
# [packages]
# web_package = httpd
# ftp_package = vsftpd
# [services]
# web_service = httpd
# ftp_service = vsftpd

# Custom facts are stored in the variable
# ansible_facts.ansible_local. In this variable, you use the
# filename of the custom fact file and the label in the
# custom fact file.
# {{ ansible_facts['ansible_local']['custom']['packages']['web_package'] }}

# exercises
# 1. Create a custom fact file with the name
# custom.fact and the following contents:
[software]
package = httpd
service = httpd
state = started
enabled = true
# 2. Write a playbook with the name
# copy_facts.yaml and the following contents:
---
- name: copy custom facts
  hosts: ansible1
  tasks:
  - name: create the custom facts directory
    file:
      state: directory
      recurse: yes
      path: /etc/ansible/facts.d
  - name: copy the custom facts
    copy:
      src: custom.fact
      dest: /etc/ansible/facts.d
# 3. Apply the playbook using 
ansible-playbook copy_facts.yaml.
# 4. Check the availability of the custom facts by using 
ansible all -m setup -a "filter=ansible_local"
# 5. Use an ad hoc command to ensure that the httpd
# service is not installed on any of the managed servers: 
ansible all -m yum -a "name=httpd state=absent"
# 6. Create a playbook with the name
# setup_with_facts.yaml that installs and enables
# the httpd service, using the custom facts:
---
- name: install and start the web service
  hosts: ansible1
  tasks:
  - name: install the package
    yum:
      name: "{{ ansible_facts['ansible_local']['custom']['package'] }}"
      state: latest
  - name: start the service
    service:
      name: "{{ ansible_facts['ansible_local']['custom']['service'] }}"
      state: "{{ ansible_facts['ansible_local']['custom']['state'] }}"
      enabled: "{{ ansible_facts['ansible_local']['custom']['enabled'] }}"
# 7. Run the playbook to install and set up the service by using 
ansible-playbook setup_with_facts.yaml
# 8. Use an ad hoc command to verify the service is running: 
ansible ansible1 -a "systemctl status httpd"

# variables
# Variables are used to separate static data from dynamic data. 
# By putting the dynamic data in variables, you make it easier
# to manage the dynamic data, in particular if the variables
# are excluded from external files.
# To define a variable, you can just use the key: value
# structure in a vars section in the play header.
# sample 
---
- name: using variables
  hosts: ansible1
  vars:
    ftp_package: vsftpd
  tasks:
  - name: install package
    yum:
      name: "{{ ftp_package }}"
      state: latest

# For small playbooks this
# approach can work fine, but as a playbook grows bigger
# and gets more complex, you can easily lose oversight. For
# that reason, it is common to define variables in include
# files. Specific host and host group variables can be used
# as include files but it’s also
# possible to include an arbitrary file as a variable file,
# using the vars_files: statement. Notice that the
# vars_files: parameter can have a single value or a list
# providing multiple values.
# sample playbook file
---
- name: using a variable include file
  hosts: ansible1
  vars_files: vars/common
  tasks:
    - name: install package
      yum:
        name: "{{ my_package }}"
        state: latest
# sample vars/common file
my_package: nmap
my_ftp_service: vsftpd
my_file_service: smb

# host and group variables
# If you want to use host variables, you must create a
# subdirectory with the name host_vars within the Ansible
# project directory. In this directory, create a file that
# matches the inventory name of the host to which the
# variables should be applied. So the variables for host
# ansible1 are defined in host_vars/ansible1. To use host
# group variables, you use a similar approach. To start, you
# create a directory with the name group_vars. In this
# directory, a file with the name of the host group is
# created, and in this file all variables are defined. So if you
# want to define variables for the host group web servers,
# you need to create a file with the name
# group_vars/webservers.


# 1. Create a project directory in your home directory. Type 
mkdir ~/exansible 
# to create the exansible project directory, and use 
cd ~/exansible 
# to go into this directory.
2. Type 
cp ../ansible.cfg . 
# to copy the ansible.cfg file that you used before. 
# No further modifications to this file are required.
# 3. Do the same for the inventory file.
# 4.Create the file webservers.yaml, containing the
# following contents. Notice that nothing is really
# changed by running this playbook. It just uses
# the debug module to show the current value of
# the variables.
---
- name: configure web services
  hosts: web
  tasks:
  - name: this is the {{ web_package }} package
    debug:
      msg: "Installing {{ web_package }}"
  - name: this is the {{ web_service }} service
    debug:
      msg: "Starting the {{ web_service }}"
# 5. Create the file group_vars/web with the following contents:
web_package: httpd
web_service: httpd
# 6. Run the playbook with some verbosity to verify it is working by using 
ansible-playbook -vv webservers.yaml

# multivalued variables :
# array example
users:
 - linda:
   username: linda
   homedir: /home/linda
   shell: /bin/bash
 - lisa:
   username: lisa
   homedir: /home/lisa
   shell: /bin/bash
 - anna:
   username: anna
   homedir: /home/anna
   shell: /bin/bash

# dictionary example
users:
  linda:
    username: linda
    homedir: /home/linda
    shell: /bin/bash
  lisa:
    username: lisa
    homedir: /home/lisa
    shell: /bin/bash
  anna:
    username: anna
    homedir: /home/anna
    shell: /bin/bash

# reference dict example
---
- name: show dictionary also known as hash
  hosts: ansible1
  vars_files:
  - vars/users-dictionary
  tasks:
  - name: print dictionary values
    debug:
    msg: "User {{ users.linda.username }} has homedirectory {{ users.linda.homedir }} and shell {{ users.linda.shell }}"
# the form bellow is also valid
# "User {{ users['linda']['username']}} has homedirectory {{ users['linda']['homedir'] }} and shell {{ users['linda']['shell'] }}"

# Magic variables are variables that are set
# automatically by Ansible to reflect an Ansible internal
# state. There are about 30 magic variables;
# check them all out here
# https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html#special-variables

# The most important thing that you should remember
# about magic variables is that you cannot use their name
# for anything else. If you try to set a magic variable to
# another value anyway, it always resets to the default
# internal value.

# magic variables example
ansible localhost -m debug -a 'var=hostvars["ansible1"]'

# variable precedence
# The most important advice is to just keep
# it simple and avoid using variables with the same names
# that are defined at different levels. That way, you avoid
# having to think about variable precedence.

# If a variable with the same name is defined at different
# levels anyway, the most specific variable always wins.
# Variables that are defined while running the playbook
# command using the -e key=value command-line
# argument have the highest precedence. After variables
# that are passed as command-line options, playbook
# variables are considered. Next are variables that are
# defined for inventory hosts or host groups.

# vault
# Sometimes, you must deal with sensitive data when
# working with Ansible—think about webkeys, passwords,
# and other types of sensitive data that you really shouldn’t
# store as plain text in a playbook. Ansible Vault is the
# solution to that problem. You can use Ansible Vault to
# encrypt and decrypt sensitive data to make it unreadable,
# and only while accessing data does it ask for a password
# so that it is decrypted.

ansiblevault create secret.yaml
# Ansible Vault prompts for a password 
# and then opens the file using the default editor.
# If a password file is used, 
# the encrypted variable file can be created using
ansible-vault create --vault-passwordfile=passfile secret.yaml.
# Apart from using ansible-vault create to create a new
# encrypted file, you can use the command 
ansible-vault encrypt 
# to encrypt one or more existing files. The
# encrypted file can next be used from a playbook, where a
# password needs to be entered to decrypt.
# Alternatively, the 
ansible-vault decrypt 
# command can be used to decrypt the file.

# use in playbooks
# When a Vault-encrypted file is accessed from a playbook,
# a password must be entered. To have the ansibleplaybook
# command prompt for a password, you need to
# tell the appropriate option. The option --vault-id
# @prompt provides the most elegant option, where the
# ansible-playbook command prompts for a password
# for each of the Vault-encrypted files that may be used.
# Using --vault-id @prompt enables a playbook to work
# with multiple Vault-encrypted files where these files are
# allowed to have different passwords set. If all Vaultencrypted
# files a playbook refers to have the same
# password set, you can use the command ansibleplaybook
# --ask-vault-pass.
# Alternatively, you can use the command ansibleplaybook
# --vault-password-file=secret to obtain
# the Vault password from a password file. The password
# file should contain a string that is stored as a single line
# in the file. Make sure the vault password file is protected
# through file permissions, such that it is not accessible by
# unauthorized users!

# exercises
# 1. Create a secret file containing encrypted values
# for a variable user and a variable password by using 
ansible-vault create secrets.yaml
# Set the password to password and enter the following lines:
username: bob
pwhash: password
# 2. Create the file create-users.yaml and provide the following contents:
---
- name: create a user with vaulted variables
  hosts: ansible1
  vars_files:
    - secrets.yaml
  tasks:
  - name: creating user
    user:
      name: "{{ username }}"
      password: "{{ pwhash }}"
# 3. Run the playbook by using 
ansible-playbook --ask-vault-pass create-users.yaml
# Provide the password when asked for it.
# 4. Change the current password on secrets.yaml by using 
ansible-vault rekey secrets.yaml
# and set the new password to secretpassword.
# 5. To automate the process of entering the password, use 
echo secretpassword > vault-pass
# 6. Use 
chmod 400 vault-pass 
# to ensure the file is readable for the ansible user only; this is
# about as much as you can do to secure the file.
# 7. Verify that it’s working by using 
ansibleplaybook --vault-password-file=vaultpass create-users.yaml.

# capture command output
# the result of commands can be used as a variable, 
# using the register parameter in a task.
# example 
---
- name: test register
  hosts: ansible1
  tasks:
  - shell: cat /etc/passwd
    register: passwd_contents
  - debug:
      var: "passwd_contents"

# Notice that in this playbook no names are used for tasks.
# Using names for tasks is not mandatory; it’s just
# recommended in more complex playbooks because this
# convention makes identification of the tasks easier.

# questions
# 1. What are the two requirements for working with custom facts?
# 2. Which module is used to enable fact gathering or
# to run fact gathering manually?
# 3. What needs to be done to use a fact cache?
# 4. How can you include a variables file in a playbook?
# 5. How do you set variables that apply to a group of
# hosts as defined in the inventory?
# 6. Which type of multivalued variable should you
# use if you want to use a loop to parse through the different values?
# 7. Which magic variable can be used to request
# current settings for variables on a specific host?
# 8. How do you change the password on a file that
# has been encrypted with ansible-vault?
# 9. How can a Vault-encrypted file that contains
# variables be assigned to hosts in a specific inventory host group?
# 10. You have used register in a playbook to register
# the result of a command in a variable
# cmd_result. How would you show the exit code
# of the command in a playbook?

# lab custom facts
# 1. Create an inventory file where server1 is member of
# the host group named file and server is member
# of the host group named lamp.
# Create a custom facts file that contains a section
# named packages and set the following variables:
# smb_package = samba
# ftp_package = vsftpd
# db_package = mariadb
# web_package = httpd
# firewall_package = firewalld
# Create another custom facts file that contains a
# section named services and set the following variables:
# smb_service = smbd
# ftp_service = vsftpd
# db_service = mariadb
# web_service = httpd
# firewall_service = firewalld
# Create a playbook with the name copy_facts.yaml
# that copies these facts to all managed hosts. In this
# playbook define a variable remote_dir to specify the
# directory the fact files should be copied to. Use the
# variable fact_file to copy the fact files to the
# appropriate directories.
# Run the playbook and verify whether it works.

# 2. create a playbook that
# uses the facts to set up the rest of the environment. Make
# sure it meets the following requirements:
# Use a variable inclusion file with the name
# allvars.yaml and set the following variables:
# web_root = /var/www/html
# ftp_root = /var/ftp
# Create a playbook that sets up the file services and
# the web services. Also ensure the playbook opens
# the firewalld firewall to provide access to these servers.
# Make sure the webservice provides access to a file
# index.html, which contains the text "Welcome to the Ansible Web Server."
# Run the playbook and use ad hoc commands to
# verify that the services have been started.

# loops and items
# Some modules enable you to provide a list that needs to be processed. 
# Many modules don’t, and in these cases, it makes sense to use a loop mechanism 
# to iterate over a list of items. Take, for instance, the yum module. 
# While specifying the names of packages, you can use a list of packages. 
# If, however, you want to do something similar for the service module, 
# you find out that this is not possible. That is where loops come in.

# example basic
---
- name: install and start services
  hosts: ansible1
  tasks:
  - name: install packages
    yum: name:
      - vsftpd
      - httpd
      - samba
      state: latest
  - name: start the services
    service:
      name: "{{ item }}"
      state: started
      enabled: yes
    loop:
    - vsftpd
    - httpd
    - smb

# example with vars
---
- name: install and start services
  hosts: ansible1
  vars:
    services:
    - vsftpd
    - httpd
    - smb
  tasks:
  - name: install packages
    yum: 
      name:
      - vsftpd
      - httpd
      - samba
      state: latest
  - name: start the services
    service:
      name: "{{ item }}"
      state: started
      enabled: yes
    loop: "{{ services }}"

# modify the playbook above so thet the vars are taken from a file

# example complex variables (lists)
# vars file
users:
  - username: linda
    homedir: /home/linda
    shell: /bin/bash
    groups: wheel
  - username: lisa
    homedir: /home/lisa
    shell: /bin/bash
    groups: users
  - username: anna
    homedir: /home/anna
    shell: /bin/bash
    groups: users
# playbook
---
- name: create users using a loop from a list
  hosts: ansible1
  vars_files: vars/users-list
  tasks:
  - name: create users
    user:
      name: "{{ item.username }}"
      state: present
      groups: "{{ item.groups }}"
      shell: "{{ item.shell }}"
    loop: "{{ users }}"

# dictionaries is not supported, 
# the only way to loop over dictionaries is to use the dict2items filter.
# check docs for examples

# Since Ansible 2.5, using loop has been the command way to iterate over values 
# In earlier versions of Ansible, the with_keyword statement was used.

# exercises

# 1. Use your editor to define a variables file with the name 
# vars/packages and the following contents:
packages:
- name: httpd
  state: absent
- name: vsftpd
  state: installed
- name: mysql-server
  state: latest
# 2. Use your editor to define a playbook with the name exercise.yaml and create the play header:
- name: manage packages using a loop from a list
  hosts: ansible1
  vars_files: vars/packages
  tasks:
# 3. Continue the playbook by adding the yum task that will manage the packages, 
# using the packages variable as defined in the vars/packages variable include file:
- name: manage packages using a loop from a list
  hosts: ansible1
  vars_files: vars/packages
  tasks:
  - name: install packages
    yum:
      name: "{{ item.name }}"
      state: "{{ item.state }}"
    loop: "{{ packages }}"
# 4. Run the playbook using 
ansible-playbook exercise.yaml
# and observe the results. In the results you should see which packages 
# it is trying to manage and in which state it is trying to get the packages.

# In Ansible, you can use a when statement to run tasks conditionally. 
# Multiple tests can be done using when; for instance, 
# you can test whether a variable has a specific value, 
# whether a file exists, whether a minimal amount of memory is available, and more.

# example equals
---
- name: conditional install
  hosts: all
  tasks:
  - name: install apache on Red Hat and family
    yum:
      name: httpd
      state: latest
    when: ansible_facts[’os_family’] == "RedHat"
  - name: install apache on Ubuntu and family
    apt:
      name: apache2
      state: latest
    when: ansible_facts[’os_family’] == "Debian"

 # example defined
---
- name: check for existence of devices
  hosts: all
  tasks:
  - name: check if /dev/sda exists
    debug:
      msg: a disk device /dev/sda exists
    when: ansible_facts[’devices’][’sda’] is defined
  - name: check if /dev/sdb exists
    debug:
      msg: a disk device /dev/sdb exists
    when: ansible_facts[’devices’][’sdb’] is defined
  - name: dummy test, intended to fail
    debug:
      msg: failing
    when: dummy is defined
  - name: check if /dev/sdc does not exist
    debug:
      msg: there is no /dev/sdc device
    when: ansible_facts[’devices’][’sdc’] is not defined

# example greater/lesser
---
- name: conditionals test
  hosts: all
  tasks:
  - name: install vsftpd if sufficient memory available
    package:
      name: vsftpd
      state: latest
    when: ansible_facts['memory_mb']['real']['free'] > 50

# exampl variable in list
---
- name: test if variable is in another variables list
  hosts: all
  vars_prompt:
  - name: my_answer
    prompt: which package do you want to install
  vars:
    supported_packages:
    - httpd
    - nginx
  tasks:
  - name: something
    debug:
      msg: you are trying to install a supported package
    when: my_answer in supported_packages

# example and/or
---
- name: testing multiple conditions
  hosts: all
  tasks:
  - name: showing output
    debug:
      msg: using CentOS 8.1
    when: > 
      ansible_facts[’distribution_version’] == "8.1" 
      and 
      ansible_facts[’distribution’] == "CentOS"

# example complex
---
- name: using multiple conditions
  hosts: all
  tasks:
  - package:
      name: httpd
      state: removed
    when: >
      ( ansible_facts[’distribution’] == "RedHat"
      and
        ansible_facts[’memfree_mb’] < 512 )
      or
      ( ansible_facts[’distribution’] == "CentOS"
      and
        ansible_facts[’memfree_mb’] < 256 )

# example loop and when
---
- name: conditionals test
  hosts: all
  tasks:
  - name: update the kernel if sufficient space
is available in /boot
    package:
      name: kernel
      state: latest
    loop: "{{ ansible_facts[’mounts’] }}"
    when: >
      item.mount == "/boot" 
      and
      item.size_available > 200000000

# example register and loop
---
- name: test register
  hosts: all
  tasks:
    - shell: cat /etc/passwd
      register: passwd_contents
    - debug:
        msg: passwd contains user lisa
      when: passwd_contents.stdout.find(’lisa’) != -1

# jinja filters
# https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_filters.html

# https://docs.python.org/2/library/stdtypes.html#string-methods

# example jinja filter / python string methods
vars:
  - mystring: foobar something

tasks:
- name: capitalize filter
  debug:
    # jinja filter
    msg: "{{ mystring|capitalize() }}"
- name: capitalize method
  debug:
    # python string method
    msg: "{{ mystring.capitalize() }}"

# Note that when using register, you might want to define a task
# that runs a command that will fail, 
# just to capture the return code of that command, 
# after which the playbook should continue. 
# If that is the case, you must ensure that ignore_errors: yes
# is used in the task definition. The default behavior 
# is that if a task fails, execution of the playbook is aborted, 
# and no other tasks run.

# exercise
# 1. Use your editor to create a new file with the name exercise.yaml. 
# Start writing the play header as follows:
---
- name: restart sshd service if httpd is running
  hosts: ansible1
  tasks:
# 2. Add the first task, which checks whether the httpd service 
# is running, using command output that will be registered. 
# Notice the use of ignore_errors: yes. 
# This line makes sure that if the service is not running, 
# the play is still executed further.
---
- name: restart sshd service if httpd is running
  hosts: ansible1
  tasks:
  - name: get httpd service status
    command: systemctl is-active httpd
      ignore_errors: yes
      register: result
# 3. Add a debug task that shows the output of the command 
# so that you can analyze what is currently in the registered variable:
---
- name: restart sshd service if httpd is running
  hosts: ansible1
  tasks:
  - name: get httpd service status
    command: systemctl is-active httpd
    ignore_errors: yes
    register: result
  - name: show result variable contents
    debug:
      msg: printing the registered variable "{{ result }}"
# 4. Complete the playbook by including the service task, 
# which is started only if the value stored in result.rc 
# (which is the return code of the command that was registered) contains a 0. 
# This is the case if the previous command executed successfully.
---
- name: restart sshd service if httpd is running
  hosts: ansible1
  tasks:
  - name: get httpd service status
    command: systemctl is-active httpd
    ignore_errors: yes
    register: result
  - name: show result variable contents
    debug:
      msg: printing the registered variable "{{ result }}"
  - name: restart sshd service
    service:
      name: sshd
      state: restarted
    when: result.rc == 0
# 5. Use an ad hoc command to make sure the httpd service is installed:
ansible ansible1 -m yum -a "name=httpd state=latest"
# 6. Use an ad hoc command to make sure the httpd service is stopped: 
ansible ansible1 -m service -a "name=httpd state=stopped".
# 7. Run the playbook using 
ansible-playbook exercise.yaml 
# and analyze the result. You should see 
# that the playbook skips the service task.
# 8. Type 
ansible ansible1 -m service -a "name=httpd state=started"
# and run the playbook again, using 
ansible-playbook exercise.yaml
# Playbook execution at this point should be successful.

# handlers (dependencies)
# A handler is a task that is triggered 
# and is executed by a another successful task.
# To work with handlers, you should define a notify statement 
# at the level where the task is defined. 
# The notify statement should list the name of the handler.
# The handlers are listed at the end of the play.

# example
---
- name: create file on localhost
  hosts: localhost
  tasks:
  - name: create index.html on localhost
    copy:
      content: "welcome to the webserver"
      dest: /tmp/index.html
- name: set up web server
  hosts: all
  tasks:
    - name: install httpd
      yum:
        name: httpd
        state: latest
    - name: copy index.html
      copy:
        src: /tmp/index.html
        dest: /var/www/html/index.html
      notify:
        - restart_web
    - name: copy nothing - intended to fail
      copy:
        src: /tmp/nothing
        dest: /var/www/html/nothing.html
  handlers:
    - name: restart_web
      service:
        name: httpd
        state: restarted

# The first play is used to define the file index.html on localhost. 
# Next, this file is used in the second play to set up the web server.
# The handler is triggered from the task where the copy module 
# is used to copy the index.html file. If this task is successful, 
# the notify statement calls the handler. Notice that handlers 
# can be specified as a list.
# All tasks up to copy index.html run successfully. 
# However, the task copy nothing fails, which is why 
# the handler does not run. The solution seems easy: 
# the handler doesn’t run because the task that copies 
# the file /tmp/nothing fails as the source file doesn’t exist. 
# So the solution seems simple: create the source file 
# using touch /tmp/nothing on the control host and run the task again.
# If a handler is triggered and a task that is later in the play fails, 
# the handler will not be executed on the node where 
# the subsequent task has failed. There are two solutions 
# to prevent this. To start with, you can use 
# force_handlers: true in the play header to ensure that 
# the handler will run anyway. You also can use the more generic 
# ignore_errors: true statement in the play header to accomplish
# the same thing. Because force_handlers: true is more specific, 
# using that option is preferred if you just need to make sure 
# that your handlers will run.

# exercises
# 1. Open a playbook with the name exercise.yaml. 
# 2. Define the play header:
---
- name: update the kernel
  hosts: all
  force_handlers: true
  tasks:
# 3. Add a task that updates the current kernel:
---
- name: update the kernel
  hosts: all
  force_handlers: true
  tasks:
  - name: update kernel
    yum:
      name: kernel
      state: latest
    notify: reboot_server
# 4. Add a handler that reboots the server 
# in case the kernel was successfully updated:
---
- name: update the kernel
  hosts: all
  force_handlers: true
  tasks:
  - name: update kernel
    yum:
      name: kernel
      state: latest
    notify: reboot_server
  handlers:
  - name: reboot_server
    command: reboot
# 5. Run the playbook using 
ansible-playbook exercise.yaml 
# and observe its result. Notice that the handler runs 
# only if the kernel was updated. If the kernel already was
# at the latest version, nothing has changed and 
# the handler does not run. Also notice that it wasn’t 
# really necessary to use force_handlers in the play header, 
# but by using it anyway, at least you now know where to use it.

# Tasks in Ansible playbooks are executed 
# in the order they are specified. 
# If a task in the playbook fails to execute on a host, 
# the task generates an error and 
# the play does not further execute on that specific host. 
# This also goes for handlers: if any task that follows 
# the task that triggers a handler fails, the handlers do not run. 
# In both of these cases, it is important to know that the tasks 
# that have run successfully still generate their result. 
# Because this can give an unexpected result, it is important 
# to always restore the original situation if that happens.

# When you want the entire playbook to stop executing on all hosts 
# when a failing task is encountered you can use any_errors_fatal 
# in the play header.

# example ignore errons
---
- name: restart sshd only if crond is running
  hosts: all
  tasks:
    - name: get the crond server status
      command: /usr/bin/systemctl is-active crond
      ignore_errors: yes
      register: result
    - name: restart sshd based on crond status
      service:
        name: sshd
        state: restarted
      when: result.rc == 0

 # example force handlers
 ---
- name: create file on localhost
  hosts: localhost
  tasks:
  - name: create index.html on localhost
    copy:
      content: "welcome to the webserver"
      dest: /tmp/index.html
- name: set up web server
  hosts: all
  force_handlers: yes
  tasks:
    - name: install httpd
      yum:
        name: httpd
        state: latest
    - name: copy index.html
      copy:
        src: /tmp/index.html
        dest: /var/www/html/index.html
      notify:
        - restart_web
    - name: copy nothing - intended to fail
      copy:
        src: /tmp/nothing
        dest: /var/www/html/nothing.html
  handlers:
    - name: restart_web
      service:
        name: httpd
        state: restarted

 # example failde when
 ---
- name: demonstrating failed_when
  hosts: all
  tasks:
  - name: run a script
    command: echo hello world
    ignore_errors: yes
    register: command_result
    failed_when: "'world' in command_result.stdout"
  - name: see if we get here
    debug:
      msg: second task executed

 # example changed when
 ---
- name: demonstrate changed status
  hosts: all
  tasks:
  - name: check local time
    command: date
    register: command_result
    changed_when: false
  - name: print local time
    debug:
      var: command_result.stdout

 # When you are working with conditional statements, 
 # blocks can be very useful. A block is a group of tasks 
 # to which a when statement can be applied. As a result, 
 # if a single condition is true, multiple tasks can be executed.

 # example blocks
 - name: simple block example
   hosts: all
   block:
   - name: remove a file
     shell:
       cmd: rm /var/www/html/index.html
   - name: printing status
     debug:
       msg: block task was operated
   rescue:
   - name: create a file
     shell:
       cmd: touch /tmp/rescuefile
   - name: printing rescue status
     debug:
       msg: rescue task was operated
   always:
   - name: always write a message to logs
     shell:
       cmd: logger hello
   - name: always printing this message
     debug:
       msg: this message is always printed

# Blocks can be used for simple error handling as well, 
# in such a way that if any task that is defined 
# in the block statement fails, the tasks that are defined 
# in the rescue section are executed. Besides that, 
# an always section can be used to define tasks 
# that should always run, regardless of the success 
# or failure of the tasks in the block.

# example rescue and always
---
- name: using blocks
  hosts: all
  tasks:
  - name: intended to be successful
  block:
  - name: remove a file
    shell:
      cmd: rm /var/www/html/index.html
  - name: printing status
    debug:
      msg: block task was operated
  rescue:
  - name: create a file
    shell:
      cmd: touch /tmp/rescuefile
  - name: printing rescue status
    debug:
      msg: rescue task was operated
  always:
  - name: always write a message to logs
    shell:
      cmd: logger hello
  - name: always printing this message
    debug:
      msg: this message is always printed

# the tasks in the block were successfully executed, 
# and for that reason, the tasks in the rescue section 
# were all skipped, and the tasks in the always section 
# were also executed successfully. As a result of the code
# in this specific playbook, the next time that the same playbook 
# is used, it will not be able to run the tasks in the block statement 
# (as the file was already removed in the previous run) and, 
# for that reason, run the tasks in the rescue statement 
# as well as the tasks in always.

# # questions
# 1. If a loop is used on the contents of the variable 
# “{{ services }}”, what is the name of the specific variable 
# that should be used while iterating over the different values?
# 2. What should you do to loop over the values in a dictionary?
# 3. Which statement should you use to run a task only 
# if a specific condition is true?
# 4. What do you need to include in your playbook 
# to have it execute a task only if the variable myvar exists?
# 5. How do you write a when statement that tests whether 
# the variable myvar has the string value “myvalue”?
# 6. Which conditional test should you use to verify 
# that mypackage is a value in the list mypackages?
# 7. How would you write a test that checks whether var1 
# has the value value1 and var2 has the value value2, 
# or var3 has the value value3 and var4 has the value value4?
# 8. What can you do to check whether the output of a command, 
# as registered in the variable cmd_out using register, 
# contains the text “error”?
# 9. How can you make sure that a play continues, 
# even if a specific task has resulted in an error?
# 10. How can you stop execution of a complete playbook 
# if any task generates an error?

# lab
# Write a playbook that meets the following requirements. 
Use multiple plays in a way that makes sense.
# • Write a first play that installs the httpd and 
mod_ssl packages on host ansible2.
# • Use variable inclusion to define the package names 
in a separate file.
# • Use a conditional to loop over the list of packages 
to be installed.
# • Install the packages only if the current operating system 
# is CentOS or RedHat (but not Fedora) version 8.0 or later. 
# If that is not the case, the playbook should fail 
# with the error message “Host hostname does not meet 
# minimal requirements,” where hostname is replaced 
# with the current host name.
# • On the Ansible control host, create a file /tmp/index.html. 
# This file must have the contents “welcome to my webserver”.
# • If the file /tmp/index.html is successfully copied to 
# /var/www/html, the web server process must be restarted. 
# If copying the package fails, the playbook should show 
# an error message.
# • The firewall must be opened for the http as well as 
# the https services.
